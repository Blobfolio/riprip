/*!
# Rip Rip Hooray: Drive Vendors, Models, and Read Offsets
*/

use crate::{
	RipRipError,
	SAMPLES_PER_SECTOR,
};
use dactyl::traits::BytesToSigned;
use std::fmt;



/// # Min Offset.
const MIN_OFFSET: i16 = -5880;

/// # Max Offset.
const MAX_OFFSET: i16 = 5880;

/// # Max Drive Vendor Length.
const DRIVE_VENDOR_LEN: usize = 8;

/// # Max Drive Model Length.
const DRIVE_MODEL_LEN: usize = 16;

// The data generated by build.rs. It is a constant array of known
// (DriveVendorModel, ReadOffset) pairs.
include!(concat!(env!("OUT_DIR"), "/drive-offsets.rs"));



#[derive(Debug, Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
/// # Drive Vendor/Model.
///
/// Their sizes are capped at 8 and 16 respectively, so we can store them in
/// a single fixed buffer more efficiently than separate strings, while also
/// making it `Copy` and compare-friendly.
///
/// The vendor may be unspecified, but the model is always present.
pub struct DriveVendorModel([u8; 24]);

impl fmt::Display for DriveVendorModel {
	fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
		let vendor = self.vendor();
		if ! vendor.is_empty() {
			f.write_str(vendor)?;
			f.write_str(": ")?;
		}
		f.write_str(self.model())
	}
}

impl DriveVendorModel {
	/// # New!
	///
	/// Convert two strings to our compact model.
	///
	/// ## Errors
	///
	/// This will return an error if the lengths are out of range, or the
	/// model number is missing.
	pub(crate) fn new(mut vendor: &str, mut model: &str) -> Result<Self, RipRipError> {
		vendor = vendor.trim();
		model = model.trim();
		if vendor.len() > DRIVE_VENDOR_LEN { Err(RipRipError::DriveVendor) }
		else if ! (1..=DRIVE_MODEL_LEN).contains(&model.len()) {
			Err(RipRipError::DriveModel)
		}
		else {
			let mut buf = [0_u8; 24];
			for (b, v) in buf.iter_mut().zip(vendor.bytes()) {
				*b = v.to_ascii_uppercase();
			}
			for (b, v) in buf.iter_mut().skip(DRIVE_VENDOR_LEN).zip(model.bytes()) {
				*b = v.to_ascii_uppercase();
			}
			Ok(Self(buf))
		}
	}

	#[allow(unsafe_code)]
	#[must_use]
	/// # Vendor.
	///
	/// Note: This may be empty.
	pub fn vendor(&self) -> &str {
		if self.0[0] == 0 { "" }
		else {
			let mut chunk = &self.0[..DRIVE_VENDOR_LEN];
			while let [ rest @ .., 0 ] = chunk { chunk = rest; }

			// Safety: the data is converted from &str slices for storage, so
			// will be valid &str when converted back.
			unsafe { std::str::from_utf8_unchecked(chunk) }
		}
	}

	#[allow(unsafe_code)]
	#[must_use]
	/// # Model.
	///
	/// A model number is always present.
	pub fn model(&self) -> &str {
		let mut chunk = &self.0[DRIVE_VENDOR_LEN..];
		debug_assert!(chunk.len() == DRIVE_MODEL_LEN, "BUG: incorrect model slice.");

		while let [ rest @ .., 0 ] = chunk { chunk = rest; }

		// Safety: the data is converted from &str slices for storage, so will
		// be valid &str when converted back.
		unsafe { std::str::from_utf8_unchecked(chunk) }
	}

	#[must_use]
	/// # Detect Offset.
	///
	/// If the vendor/model pair are known, return the drive offset.
	pub fn detect_offset(&self) -> Option<ReadOffset> {
		let idx = DRIVE_OFFSETS.binary_search_by_key(self, |(k, _)| *k).ok()?;
		Some(DRIVE_OFFSETS[idx].1)
	}
}



#[derive(Debug, Clone, Copy, Default, Eq, Ord, PartialEq, PartialOrd)]
/// # Read Offset.
///
/// This holds a read offset in samples, but can return values in various other
/// useful formats.
///
/// For historical reasons, values are restricted to `-5880..=5880`.
pub struct ReadOffset(i16);

impl TryFrom<i16> for ReadOffset {
	type Error = RipRipError;
	fn try_from(src: i16) -> Result<Self, Self::Error> {
		if (MIN_OFFSET..=MAX_OFFSET).contains(&src) { Ok(Self(src)) }
		else { Err(RipRipError::ReadOffset) }
	}
}

impl TryFrom<&[u8]> for ReadOffset {
	type Error = RipRipError;
	fn try_from(src: &[u8]) -> Result<Self, Self::Error> {
		if src.is_empty() { Ok(Self(0)) }
		else {
			i16::btoi(src)
				.ok_or(RipRipError::ReadOffset)
				.and_then(Self::try_from)
		}
	}
}

impl TryFrom<&str> for ReadOffset {
	type Error = RipRipError;
	fn try_from(src: &str) -> Result<Self, Self::Error> {
		Self::try_from(src.as_bytes())
	}
}

impl ReadOffset {
	#[must_use]
	/// # Is Negative?
	pub const fn is_negative(self) -> bool { self.0 < 0 }

	#[must_use]
	/// # Samples.
	pub const fn samples(self) -> i16 { self.0 }

	#[must_use]
	/// # Samples (Absolute).
	pub const fn samples_abs(self) -> u16 { self.0.abs_diff(0) }
}

impl ReadOffset {
	#[must_use]
	#[allow(clippy::cast_possible_wrap)]
	/// # Sectors.
	///
	/// Return the minimum containing sector amount.
	pub const fn sectors(self) -> i16 {
		// Flip the sector count negative if needed.
		if self.is_negative() { 0 - self.sectors_abs() as i16 }
		else { self.sectors_abs() as i16 }
	}

	#[must_use]
	#[allow(
		clippy::cast_possible_truncation,
		clippy::integer_division,
	)]
	/// # Sectors (Absolute).
	///
	/// Return the minimum containing sector amount.
	///
	/// TODO: use div_ceil as soon as that is stabilized!
	pub const fn sectors_abs(self) -> u16 {
		if self.0 == 0 { return 0; }

		let samples_abs = self.samples_abs();

		// Floor.
		let div = samples_abs / SAMPLES_PER_SECTOR as u16;

		// Add one if there's a remainder.
		if 0 == samples_abs % SAMPLES_PER_SECTOR as u16 { div }
		else { div + 1 }
	}
}



#[cfg(test)]
mod test {
	use super::*;


	#[test]
	fn t_vendormodel() {
		// Test some failures first.
		for (v, m) in [
			("", ""),
			("Foo", ""),
			("Immatoolongvendor", "Bar"),
			("Foo", "Immatoolongmodelnumber"),
		] {
			assert!(DriveVendorModel::new(v, m).is_err());
		}

		// Test things that should work.
		let vm = DriveVendorModel::new("\nPioneer ", "BD-RW   BDR-XD05   ")
			.expect("Unable to create DriveVendorModel.");
		assert_eq!(vm.vendor(), "PIONEER");
		assert_eq!(vm.model(), "BD-RW   BDR-XD05");
		assert_eq!(vm.to_string(), "PIONEER: BD-RW   BDR-XD05");
		assert_eq!(vm.detect_offset(), Some(ReadOffset(667)));
	}

	#[test]
	fn t_offset() {
		for (raw, samples, samples_abs, sectors, sectors_abs) in [
			("0", 0_i16, 0_u16, 0_i16, 0_u16),
			("123", 123_i16, 123_u16, 1_i16, 1_u16),
			("-123", -123_i16, 123_u16, -1_i16, 1_u16),
			("588", 588_i16, 588_u16, 1_i16, 1_u16),
			("-588", -588_i16, 588_u16, -1_i16, 1_u16),
			("667", 667_i16, 667_u16, 2_i16, 2_u16),
			("-667", -667_i16, 667_u16, -2_i16, 2_u16),
		] {
			let offset = ReadOffset::try_from(raw).expect("ReadOffset failed.");
			assert_eq!(offset.samples(), samples);
			assert_eq!(offset.samples_abs(), samples_abs);
			assert_eq!(offset.sectors(), sectors);
			assert_eq!(offset.sectors_abs(), sectors_abs);
		}
	}
}
